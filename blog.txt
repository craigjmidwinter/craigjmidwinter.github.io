1:"$Sreact.fragment"
2:I[15244,[],""]
3:I[43866,[],""]
4:I[62046,["322","static/chunks/322-53eb1d32bf710b44.js","831","static/chunks/app/blog/page-13bf16a02dcb0aba.js"],"default"]
15:I[86213,[],"OutletBoundary"]
17:I[86213,[],"MetadataBoundary"]
19:I[86213,[],"ViewportBoundary"]
1b:I[34835,[],""]
5:T119c,
Whether you’re researching smart bulbs or exploring the capabilities of your new voice assistant, you’ve probably encountered the terms Smart Home and Home Automation, and you’ve got yourself wondering, is there a difference?

While these two terms are sometimes used interchangeably and are closely related, they actually refer to slightly different things.

The term Smart Home generally refers to a class of electronic devices and sensors that can be controlled over the internet (or your local network) via your phone, computer or other devices. These devices will often have their own separate app or interface that you would use in order to control devices within certain ecosystem– for example Philips Hue smart-bulbs are Smart Home devices, and the manufacturer maintains their own app which you can use in order to control the devices within the Philips Hue ecosystem.

Home Automation, on the other hand, refers more to a methodology for using Smart Home devices. The idea behind Home Automation is to make these devices work automatically, responding to what you are doing while requiring little-to-no interaction with any sort of app or physical interface.

For example, let’s say you may have Philips Hue smart bulbs, and when you watch movies you like to have them all set up in a certain ‘scene’ (scene is general purpose term that refers to the a bunch of smart home devices set to a specific state). General smart-home use would be opening up the app on your phone and then pressing the button for the corresponding scene and then starting your movie– and then when you stop (or press pause) opening up the app again and pressing the button for the scene that you want to go back to. If you are into home automation, you would set up an automation that detected when a movie started playing and then automatically adjusted your lights to your ‘movie scene’ and then turned them back to normal when you pause or stop.

You can easily have smart home devices without doing any sort of home automation (but what’s the fun in that?) but it is very difficult to do any sort of home automation without some sort of smart home device.

To confuse matters more, often some smart home devices will have some home automation features built right into their core functionality– like the Nest thermostat, for example, automatically adjusts your temperature depending on whether it thinks you are home or away.

But built-in home automation features are not the only (and often not even the best) way to accomplish this functionality. Most home-automation enthusiasts will use some sort of hub software that serves as a middle-man to allow various devices and ecosystems to talk to each other and to use various small pieces of information from one another and combine this information to assemble the context it needs in order to better respond to more complex scenarios than any single set of devices can on their own. Hub software like this also has the added benefit of being a single point of control so that you can control all of the smart devices in your house without having to use a bunch of different apps for each device.

There are many options for what to use as your Hub. The two big free open source options are Home Assistant and OpenHAB. I have used both, and I think both projects are great and have very excellent communities. My personal day-to-day is Home Assistant, but definitely give both a try to see which has the best support for your devices and which interface you like best. These two are by no means the only options, there are a variety of other projects and also some paid options that might be worth considering depending on your requirements.

Some users are happy to just cobble together some automations using IFTTT (though, personally, I find the service really slow and a bit unreliable), but others might strive to see how deep the rabbit hole goes.

Home Automation is an excellent hobby if you like learn and problem solve. The key is being able to build fun and innovative automations is being able to identify problems, processes and systems in your day-to-day life and find ways to optimize them by breaking them down into smaller, more workable problems that can be solved. All you need to get in to it is a willingness to learn and spend time and money on stupid shit (and it definitely helps if you have a patient partner who doesn’t get too upset when you test out your new sunrise automation without giving them any warning).
6:Tfe5,
So, recently I decided to step my game up with my audio notifications for my home automation setup. I’m in the process of slowly redoing some of my YAML automations in Node-RED, and I thought what better of a time to make some improvements.

Up until recently I had been just using the built-in Home Assistant tts.google_say service to create whatever message I needed and then piping that over my whole home audio when I needed. It’s reliable and gets the job done just fine, but it’s very robotic and I wanted a voice with personality and confidence.

So, naturally, I went on Fiverr.

After some searching and listening to a lot of different samples I came across a gig from a guy named Uni V Sol who had a very impressive demo reel.

![](https://www.youtube.com/watch?v=8Iz0qAC7ymo)

Perfect. If major brands like Nike, Pepsi and AT&T trusted him to deliver their important messages, I’m sure I could trust him to deliver important notifications about my cat’s litter box being full.

So, I bought 50 words worth and sent him a list of notifications.

How did they turn out? Have a listen to my new cat litter notification:

It was super affordable and I’m really happy with how they turned out. I’ll definitely be ordering from him again once I’ve got another batch of notifications ready. [(Check out his fiverr gig here)](https://www.fiverr.com/univsolmc/record-an-urban-male-voice-over)

Now that I’ve got my fancy new notifications, let’s put them to use

I don’t really care about if these go off when I’m not home, but I don’t want them to go off while the house is in ‘Night Mode’ and wake us up. Since I’ve got more than a few notifications that need to be handled in the same way I decided to create a reusable sub-flow that I could just pass messages into from other flows.

The first node there is the entry point– every flow that is going to pass this flow a message is going to have a corresponding node that is the other side of the virtual wire. This is where the messages come in.

The way that I’ve configure this to work is that incoming messages should all have a property on the message named file that is set to the url of the file we want to play, so we’ll always send a message where msg.file = “https://server/our-notification.mp3.

It’s important to note that I set this on the message object directly and not as part of the payload. The reason that I do that is because the Home Assistant Node-RED nodes trample over the data in the payload, so setting it directly on the msg object makes it easier to persist from node to node.

From there I check the state of an input_boolean that I have set up in HASS that indicates whether or not the house is in “Night Mode”. In my setup, this entity is basically Do Not Disturb mode. This node has a “half if state” set to on, and so if any messages come in while we’re in night mode, we just ignore them.

After that it’s fairly self-explanatory– First it sets the volume of my everywhere media_player group, and then there are two different pairs of nodes that prep a the payload with a sound file, in the set it preps and plays a small blank sound file and then in the second set it preps and plays the notification file I need.

The reason for the blank spacer is because for reasons that still remain a mystery to me, often when Home Assistant tries to play an audio file and it hasn’t yet taken control of the chromecast group, I can hear the chime indicating that HASS has connected, but the audio fails to play. If it’s followed by audio in the next few minutes while HASS still has control, it plays without a hitch, so I’ve got this little blank file in there to make it work more smoothly. If you know why it does this or have a fix for it, please let me know in the comments!

And that about does it for this
flow! [If you want to check out how I’ve set up my cat litter notification, check out this post](/blog/2018-06-automatic-litterbox-notifications-using-an-home-assistant-and-node-red-with-an-external-rest-api/)!
7:T16f3,
Cleaning the cat litter– it’s the job the whole household fights over. Nothing is quite as glamourous as scooping shit out of a box in a dark corner of the basement.

It’s always these undesirable tasks that I end up putting off and forgetting about. The thing about the cat litter is that it’s a lot less of a pain in the ass to clean if you stay on top of it. Unfortunately, it’s my chore and I don’t always stay on top of it as well as I probably should- it’s not uncommon for Jess to notice that it’s getting a bit too full even though I feel like I have just cleaned it.

In any event, I wanted a solution to take the guess-work out of it and to give me a reminder when it’s full. Down the road I was thinking about gamify it and awarding myself badges and maybe keeping a highscore board for cleaning streaks and stuff.

Now, there are a number of ways you can really simply implement something pretty much exactly the same as what I’ve got here using purely Home Assistant (or HASS and Node Red or AppDaemon), but I decided I wanted to create a little external service so I could extend and fuck around with it in the future if I wanted to. I won’t go into the details of that service but if you’re really interested, let me know and I can make a post about it in the future.

**So, what does this do?**

Basically, all it consists of is a button near the litter box that I hit after I’ve cleaned the litter box to log the
fact that I’ve cleaned it. It fires a thank you tweet off and logs the cleaning in the microservice. In addition to the
api endpoint for logging the cleaning, it provides a few endpoints to provide some information to my HASS install, the
main one being an litterbox fill percentage that my HASS install uses in a sensor to determine when it should notify me
about needing to be cleaned again. Let’s look at the Node-Red flow:

[//]: # (![]&#40;/src/images/2018/12/Screenshot-2018-06-24-16.54.22.png)
It looks a little more complicated than it actually is. I tried to group it and lay it out as logically as possible. Let’s take a look at the top part of the flow

[//]: # (![]&#40;/src/images/2018/12/Screenshot-2018-06-24-16.55.55.png)
The top part of this flow just handles the litter clean button press. When it sees the event in Home Assistant, it uses the HTTP Request node to send a request to the API on the litterbox microservice to log the cleaning, thanks me on twitter, and then waits 20 seconds (I do this here because the sensor we use in Home Assistant only updates every few seconds.) before sending the reset message to the Trigger & Block node.

There is also this daily notification reset, that sends the reset message to the Trigger & Block node once a day.

**What is the trigger and block node and what does it do?**

The trigger and block node is useful node that is helpful for limiting actions that only should be triggered once. Essentially, the first message through it passes through and then locks the door behind it. In order to open the door for more messages to come through, you need to send a message where msg.reset is set. So in this case, we are firing our notification flow the first time that the litter level crosses the threshold and then the door locks. After that, we are unlocking the door once a day to allow another notification through as a reminder and also unlocking it after it gets cleaned.

**Ok, let’s take a look at the actual notification flow**

[//]: # (![]&#40;/src/images/2018/12/Screenshot-2018-06-24-16.57.10.png)
The main trigger for this part of the flow is checking the litter fill sensor I’ve got set up in Home Assistant. This is a REST sensor and it gets the percentage from my micro service’s api using an HTTP request. This type of sensor is really handy and has really limitless potential since you can use it to get any sort of data from any external REST API that you’ve got access to and use a template to read the data you want to use. This is what the configuration for my sensor looks like in my Home Assistant config

```yaml
    - platform: rest
      name: litter_percent
      unit_of_measurement: '%'
      resource: http://litterboxservice.local/catlitter/litter-percent
      icon_template: '{% if states.sensor.litter_percent.state|default(0)|int >= 75 %}mdi:emoticon-poop{% else %}mdi:cat{% endif %}'
```

Now that we’re getting the data we want, let’s look at the notifications.

So, I get these notifications in two ways. The first way I receive it is through a voice notification in the house. To
accomplish this, I just send a formatted message to
my [voice notification sub-flow that I covered in this previous post.](/blog/2018-06-i-hired-a-dude-who-voices-nike-commercials-to-tell-me-when-my-cat-litter-is-full/)

The second way I get these notifications is through twitter, and in this case I also attach a photo of the dirty litter box just for some added shaming. I’ve got a camera set up down there and a little script runs that keeps an snapshot stored on my HASS server. I’ve noticed that the night-vision images are pretty gross, so I’ve got a little flow that checks if the lights are on down there and if they are off it will turn the lights in the basement on for a bit so that the snapshot is better lit before it sends it.

The actual fill percentage isn’t based on anything but time since the last cleaning– for now, this is pretty effective but down the road I’m considering adding some load sensors to the bottom of the litter boxes in order to detect when the cats actually visit the boxes and using the number of visits since the last cleaning for this value. I’m also considering only tweeting the photo of the full litter box if I haven’t cleaned it after the first notification.

If you’ve got any questions or improvements that you want to suggest, leave me a comment!
8:T17f2,
I’ll try not to be as long-winded as I usually am, but I’m pretty proud of the bed sensor I built. Here’s a video of it working in Home Assistant:

Now, this sensor is similar to the one in [this build on the 24-7-home-security blog](http://24-7-home-security.com/how-to-make-a-wifi-bed-occupancy-sensor-arduino/), with a few changes– Instead of using the Arduino Uno for the controller, I used [this ESP8266MOD dev board](https://www.gearbest.com/transmitters-receivers-module/pp_366523.html?wid=1433363&amp;lkid=14192359). I chose this for a few reasons– it’s smaller, cheaper and it’s got wifi capabilities built in which eliminates the need for an additional ethernet/wifi shield and the router. I also chose to use one of [these little potentiometers](https://www.amazon.ca/gp/product/B0753G1ZDZ/ref=oh_aui_detailpage_o02_s00?ie=UTF8&amp;psc=1) (I used a 1k) instead of the voltage divider in the blog post– it’s smaller and it’s what I had lying around.

I’ve got a king sized bed and I wanted to get a reading on both using two FSRs. The one drawback to the ESP8266MOD is that it only has a single analog input pin– this means, if you want to read the two separately, you’ll need to multiplex them, or build two sensors. I just ended up building two sensors.

Let’s take a look at the guts of this thing:

![](/assets/blog/IMG_20180518_174346.jpg)

I thought I had taken more and better photos of this before I sealed it up and put it in place, but I guess I didn’t/ The strip thing you see goes on for 2 feet. That’s the FSR and it just sits underneath the mattress but on top of the box spring. In the final version, I made the wires that connect it to the controller much longer so that the controllers can just sit on the floor under the bed.

There’s not a heck of a lot to see in the Arduino sketch. Most of it I just patched together from pieces of code I found around the internet. All it does is connect to wifi, read the analog pin and then publish the value to my MQTT server.

```c
    #include 
    #include 
    int fsrAnalogPin = 0; // FSR is connected to analog 0
    int LEDpin = 11; // connect Red LED to pin 11 (PWM pin)
    int fsrReading; // the analog reading from the FSR resistor divider
    int LEDbrightness;
    WiFiClient espClient;
    const char * ssid = "SSID";
    const char * password = "PASSWORD";
    PubSubClient client(espClient);
    const char * mqtt_topic_bed = "sensor/bed/left";
    const char * mqtt_server = "mqtt.address";
    void loop()
    {
      // put your main code here, to run repeatedly:
      fsrReading = analogRead(fsrAnalogPin);
      Serial.print("Analog reading = ");
      Serial.println(fsrReading);
      if (!client.connected())
      {
        reconnect();
      }
      
      char buffer[10];
      dtostrf(fsrReading,0, 0, buffer);
    
      Serial.println(buffer);
      client.publish(mqtt_topic_bed, buffer);
      delay(1000);
    }
    
    void setup()
    {
      Serial.begin(9600); // We'll send debugging information via the Serial monitor
      // setup WiFi
      setup_wifi();
      client.setServer(mqtt_server, 1883);
      reconnect();
    }
    
    void reconnect()
    {
      // Loop until we're reconnected
      while (!client.connected())
      {
        Serial.print("Attempting MQTT connection...");
        // Attempt to connect
        if (client.connect("ESP8266Client", "USERNAME", "PASSWORD"))
        {
          Serial.println("connected");
        }
        else
        {
          Serial.print("failed, rc=");
          Serial.print(client.state());
          Serial.println(" try again in 5 seconds");
          // Wait 5 seconds before retrying
          delay(5000);
        }
      }
    }
    
    void setup_wifi()
    {
      delay(10);
      // We start by connecting to a WiFi network
      Serial.println();
      Serial.print("Connecting to ");
      Serial.println(ssid);
      WiFi.begin(ssid, password);
      while (WiFi.status() != WL_CONNECTED)
      {
        delay(500);
        Serial.print(".");
      }
    }
```

Once it was in place and reporting I watched to see the values it was reporting while I wasn’t in bed compared to the values that it was reporting while I was in bed. The difference in the numbers was significant and finding a number to use as the threshold between the occupied and unoccupied states was really easy. Now, I just created these sensors within Home Assistant

```yaml
    - platform: mqtt
      state_topic: 'sensor/bed/left'
      name: 'bed_left_value'
    
    - platform: mqtt
      state_topic: 'sensor/bed/right'
      name: 'bed_right_value'
    
    - platform: template
      sensors:
        bed_craig:
          friendly_name: "Bed - Craig"
          value_template: "{% if states.sensor.bed_left_value.state|int > 200 %}Occupied{% else %}Unoccupied{% endif %}"
          icon_template: "{% if states.sensor.bed_left_value.state|int > 200 %}mdi:hotel{% else %}mdi:bed-empty{% endif %}"
    
        bed_jess:
          friendly_name: "Bed - Jess"
          value_template: "{% if states.sensor.bed_right_value.state|int > 200 %}Occupied{% else %}Unoccupied{% endif %}"
          icon_template: "{% if states.sensor.bed_right_value.state|int > 200 %}mdi:hotel{% else %}mdi:bed-empty{% endif %}"
    
        bed_both:
          friendly_name: "Bed - Both"
          value_template: "{% if states.sensor.bed_jess.state == 'Occupied' and states.sensor.bed_craig.state == 'Occupied' %}Occupied{% else %}Unoccupied{% endif %}"
```

Boom! That’s all there is to it! Right now, I’ve just got it set up so that if we are both in bed, it turns off all the lights in the house other than the ones in the bedroom and arms the alarm system, and then if one of us gets out of bed it will turn on the corridor and bathroom lights on a low brightness in case one of us gets up during the night. I’ll try to remember to post any unique automations I come up with that use this sensor. If you’ve got a bed sensor or anything similar, let me know what some of your favourite automations that make use of it are in the comments!
9:T1bdc,
Garbage day is the same day every week, but somehow I haven’t developed a steady routine surrounding it. Our garbage is picked up out front, but the main way we enter and leave the house is through the back door. As a result, I’ve got a bad habit of forgetting to put out the garbage and recycling. While I haven’t come up with a way to make the bins take themselves out, I’ve come out with a nice solution to remind me to take them out and bring them back in.

This is the first part in a series of posts about how I’ve implemented my Garbage reminders. I wanted to cover this automation, because while it’s a ridiculously unnecessary automation, I think some of the components and patterns in its implementation can be followed and used individually in really interesting ways. In this post, I’m going to focus on the pattern that I follow when I need to defer a service call within Home Assistant.

So, this automation started really simply. Since Garbage day is Friday, I just set a static reminder on Thursday evening to notify me to put the garbage out, and one on Friday after work to bring it back in. The automations for both are essentially the exact same just at a different time with different message text, so we’ll just look at the first one

    - alias: 'Garbage Day'
      initial_state: 'on'
      trigger:
        platform: time
        at: '20:15:00'
      condition:
      - condition: time
        weekday:
          - thu
      action:
      - service: notify.149twitter
        data:
          message: "Tomorrow is garbage day @craigjmidwinter"

Ok, not bad, but it could be better. What if I’m not home? How about I defer these notifications until I get home when I can actually do something about it so that I don’t forget again?

We can easily make sure this doesn’t fire while we are away by adding a condition to our first automation so that it only fires when we are home–

    - alias: 'Garbage Day - Home'
      initial_state: 'on'
      trigger:
        platform: time
        at: '20:15:00'
      condition:
      - condition: time
        weekday:
          - thu
      - condition: state
        entity_id: device_tracker.craig_craig
        state: 'home'
      action:
      - service: notify.149twitter
        data:
          message: "Tomorrow is garbage day @craigjmidwinter"

But what happens if we are away when our reminder is supposed to fire while we’re out? We need an automation to handle that situation. It’s going to look very similar to the one for our home state.

    - alias: 'Garbage Day - Not Home'
      initial_state: 'on'
      trigger:
        platform: time
        at: '20:15:00'
      condition:
      - condition: time
        weekday:
          - thu
      - condition: template
        value_template: "{{ not is_state('device_tracker.craig_craig', 'home') }}"
      action:
      - service: input_boolean.turn_on
        entity_id: input_boolean.garbage_day_pending

There are a couple of key differences in this automation. The first is the template condition that we added. I’ve decided to use a template condition here instead of a simple state condition that checks for not_home because I’ve got some zones set up, so this device tracking isn’t necessarily always in the not_home state when I’m out.

The second difference is that instead of calling the notification service, I’m turning on an input boolean that we need to add to our main configuration like this–

    input_booleans:
      garbage_day_pending:

Perfect. Now we can create automations for our state change for when we arrive home, and use these being in the on state as a condition, and then in the action, we’ll trigger the service call we want to make, and then set our pending input boolean to off since the job is complete.

    - alias: 'Deferred Garbage Day Notification'
      trigger:
        platform: state
        entity_id: device_tracker.craig_craig
        to: 'home'
      condition:
      - condition: state
        entity_id: input_boolean.garbage_day_pending
        state: 'on'
      action:
      - service: notify.149twitter
        data:
          message: "Tomorrow is garbage day @craigjmidwinter"
      - service: input_boolean.turn_off
        entity_id: input_boolean.garbage_day_pending

Ok, great! But having these service calls duplicated sucks, what if we want to add on another notification platform like a facebook message or something? Then we’d need to make that change in more than one place, so lets move these to their own scripts and just call the scripts from both places. The scripts will look like this:

    garbage_notify:
      sequence:
        - service: notify.149twitter
          data:
            message: "Tomorrow is garbage day @craigjmidwinter"
        - service: notify.facebook
          data:
            message: "Tomorrow is garbage day"
            target:
              - !secret facebook_id_craig
              - !secret facebook_id_jess

Then our complete, updated automations will look like this:

    - alias: 'Garbage Day - Home'
      initial_state: 'on'
      trigger:
        platform: time
        at: '20:15:00'
      condition:
      - condition: time
        weekday:
          - thu
      - condition: state
        entity_id: device_tracker.craig_craig
        state: 'home'
      action:
      - service: script.turn_on
        entity_id: script.garbage_notify
    
    - alias: 'Garbage Day - Not Home'
      initial_state: 'on'
      trigger:
        platform: time
        at: '20:15:00'
      condition:
      - condition: time
        weekday:
          - thu
      - condition: template
        value_template: "{{ not is_state('device_tracker.craig_craig', 'home') }}"
      action:
      - service: input_boolean.turn_on
        entity_id: input_boolean.garbage_day_pending
    
    - alias: 'Deferred Garbage Day Notification'
      trigger:
        platform: state
        entity_id: device_tracker.craig_craig
        to: 'home'
      condition:
      - condition: state
        entity_id: input_boolean.garbage_day_pending
        state: 'on'
      action:
      - service: script.turn_on
        entity_id: script.garbage_notify
      - service: input_boolean.turn_off
        entity_id: input_boolean.garbage_day_pending

Fuck yeah! Now I’ll never forget to take the trash out ever again. This same pattern for deferring service calls is a super handy tool to use in order to add better context to notifications and automations.

It’s a small thing, but I personally find that it really helps make the house feel smarter– so much so that I’m considering writing a feature for Home Assistant to handle this sort of flow in a queue-worker system (for example, instead of having setting a switch, and then checking the switch when you get home to trigger the service call, you would just send the information about the service call to a ‘home’ queue and manage when the worker should be processing the jobs).

That’s it for part one! Stay tuned for part two where I’ll go over how I’m determining whether the garbage is at the curb already!
a:T221f,

https://github.com/goalfeed/hassio-goalfeed-repository
Last week I
made [this blog post](/blog/2017-11-my-house-automatically-orders-pizza-for-me-dominos-pizza-automation-using-home-assistant)
describing how to use the Telegram inline keyboard and callback functions within Home Assistant. I posted the article to
Reddit and a user left a comment wondering how to accomplish this within Node-RED, so I thought I’d make a quick post on
how to do that.

Now, I am not a Node-RED expert by any means-- it’s actually been a couple of years since I’ve tried doing anything with it, but I’ve noticed more and more people are starting to use it to handle their automations and I can definitely see it’s advantages. Personally, I haven’t encountered any real insurmountable limitations using Home Assistants baked-in YAML-based automation engine, and I’m not the most visually-oriented person so I’m not in a huge rush to start changing over all my automations, but it’s definitely a tool that I would consider in the future.

I prefaced this tutorial with the fact that I am not a Node-RED expert because there are a lot of ways this flow could be accomplished, and I’m not 100% sure if my implementation breaks any common conventions-- there could be a more Node-REDy way to do this, and if there is, please leave me a comment to let me know what you would do different!

If you are looking for a real Node-RED guru or a crash-course on some of the fundamentals of integrating Node-RED with Home Assistant, I recommend checking out the excellent [DIY Futurism blog by u/diybrad](https://diyfuturism.com/). He’s great Home Automation blogger who has got a lot of excellent posts about his implementations of automations in Node-RED and it’s a great point of reference for anybody just starting out with the tool.

## Assumptions

I’m going to assume that you already have Node-RED running and configured with your Home Assistant installation. If you haven’t, check out [this post on DIY Futurism](https://diyfuturism.com/index.php/2017/11/26/the-open-source-smart-home-getting-started-with-home-assistant-node-red/) for how to do that. Additionally, like my previous post on this matter, I’m going to assume that you have configured the telegram_bot platform using [the webhook](https://www.home-assistant.io/components/telegram_bot.webhooks/) or [polling method](https://www.home-assistant.io/components/telegram_bot.polling/) on your Home Assistant install.

Ok, now that that’s all out of the way, let’s get our hands dirty!
![](https://s3.us-west-2.amazonaws.com/mid-midwinter.cc/images/BkVNvaZRz.png)

## Inline Keyboard

If you have ever created an automation for Home Assistant in Node-RED, this is going to look pretty familiar to you. In this case, for demonstration purposes I’m just using the Inject node to trigger the initial message. In any other practical automation, you’ll probably use some other event within Home Assistant and/or have some sort of logic that is going to trigger it, but whatever that might be, the message is going to flow to the call service node in order to trigger our message. Let’s take a look at that node to see what it looks like:
![](https://s3.us-west-2.amazonaws.com/mid-midwinter.cc/images/r1bqwaZCz.png)
The really important bits of this are the ‘domain’, ‘service’, and ‘data’ field. Domain and service are pretty straight-forward. The domain is going to be ‘telegram_bot’ and the service is ‘send_message’. Now, let’s look at the data-- you can’t see it all in the screenshot and it’s hard to read all on one line anyways, so here’s a better look:

    {
      "target": "123456789",
      "title": "Want pizza?",
      "message": "You look like you are home alone. Should I order you a pizza?",
      "inline_keyboard": [
        "Gimme Pizza:\/gimmepizza",
        "No thanks:\/nopizza"
      ]
    }

You can see in our json object we are setting the target to our chat id, then setting the title and message fields, and then we have the inline_keyboard field, which is getting set to an array of a few specifically formatted strings. Each button consists of two parts, the message text and the message command. The two parts are separated by a colon with the text that your user sees coming before the colon and the message command that gets sent back to Home Assistant coming after. The message command is going to be a special text string that you make up. It has got to start with a slash and I don’t think it can contain any spaces. This command is what we will use to distinguish ‘Gimme Pizza’ from ‘No Thanks’.

## Telegram Callbacks

Now, let’s take a look at the automation flow to handle the reply!
![](https://s3.us-west-2.amazonaws.com/mid-midwinter.cc/images/BypVOTZ0z.png)
Look at this! It’s nice and small-- let’s break it down!

The first piece here is the events:all node. It sends a message down the flow for every single event that happens within Home Assistant. Obviously, we only want to react to certain events, so we’re going to pipe this into a function node to filter it out. The code in that function looks like this:

    if(msg.payload.event_type == "telegram_callback") {
        msg.payload.data = {"callback_query_id": msg.payload.event.id};
        return msg;    
    }

What this does is use an if statement to filter through all the messages coming in and only allow messages of the telegram_callback event type through, if it matches that event_type, it also manipulates the message payload before passing it on to the next node. It does this by adding an object named ‘data’ to it and initializing this object with one property on it called “callback_query_id” with the value of msg.payload.event.id. If you are wondering why msg.payload.event.id is not in quotes, that’s because in this case we are referring to the value of msg.payload.event.id not the literal string “msg.payload.event.id”.

This function here is the main reason why I said that I am not entirely sure if there is a more Node-REDy way to do this. It definitely works to do it this way, but there are two things I could see possibly going against common Node-RED. First, there may be a more simpler way of filtering out all messages that don’t match on a single value with another core node type that does not require writing code, and second (and I expect this is more of an issue than the first point) the function, while simple, has more than one responsibility-- that is to say, it both filters out messages and manipulates the message in a single node. It might be common practice to separate these responsibilities in to two different nodes in order to better represent the logic visually.

With that said, I think this is an elegant enough way of handling the data here. If you are planning on having a lot of different telegram_callback automations, I’d recommend saving the first two nodes in this as a sub-flow so that you can reuse it as the entrypoint for all your callback automations.

On to the next node!
![](https://s3.us-west-2.amazonaws.com/mid-midwinter.cc/images/HyPi-T@0M.png)
The next node here is a simple switch and if we look at how this node is configured, you can see that it is matching on the two commands that we defined in our keyboard in the initial message, with a separate exit-point for each of the two responses.
![](https://s3.us-west-2.amazonaws.com/mid-midwinter.cc/images/r1zaKabRf.png)
From both the exit point of the ‘No’ and the 'Yes' response we just flow into a change node. They both look very similar to this, the only difference is what we set the reply message to. We use this change node to add a field called message to the data object and set it to the message we want to send in the callback.  I’ve also got the yes exit point flowing into another service call just to illustrate where we would branch off and fire our automation.

Both the yes and no change nodes flow into the same service call node. Here’s how that looks--
![](https://s3.us-west-2.amazonaws.com/mid-midwinter.cc/images/HkGm9aZAM.png)![](https://149walnut.com/images/HkGm9aZAM.png)
This node calls the answer_callback_query service of telegram_bot. We set the data in this node to be an empty object by using a set of empty curly-boys (that’s definitely a technical term). We don’t need to set the data here for the same reason that we can share this node for both yes and no-- The Home Assistant service call node will look for the data object in the payload we created and use that for the data in the service call if it exists!

That should about cover it! Please feel free to comment with any questions or improvements you might have!
b:T1a65,
*Note: If you'd like to see how this is implemented with Node-RED instead, [check this post](https://midwinter.cc/post/telegram-keyboard-and-callbacks-in-home-assistant-with-node-red_r1Fa56ZRz/#top).*

A while ago I made [this post](https://midwinter.cc/post/my-house-orders-pizza-for-me-dominos-pizza-automation-using-home-assistant_SJY1zsc0W/) about creating an automation and Home Assistant integration to allow my house to order pizza for me. In the months since, I’ve noticed it referenced on a few occasions when people have been looking for more information on how to use the inline keyboard functionality in conjunction with the Telegram callbacks in order to create an actionable notification in Home Assistant.
![](https://s3.us-west-2.amazonaws.com/mid-midwinter.cc/images/BJWTz95Tf.png)
Since that post is a bit long and only partially focuses on that functionality, I thought I’d cut the bullshit and make a quick post that focuses on it. If anyone has questions about this, feel free to leave a comment and I’ll try to answer. I’ll also try and keep this page updated with the answers to any questions that come up over time.

This post makes the assumption that you are familiar with the basic structure for defining automations in Home Assistant. It also makes the assumption that you have added the telegram bot to your configuration by following the instructions for either the [webhook method](https://www.home-assistant.io/components/telegram_bot.webhooks/) or the [polling method](https://www.home-assistant.io/components/telegram_bot.polling/).

I’ll stick with the original example since it is really straight forward. At its simplest, using the Telegram inline keyboard and the Telegram callback really only requires two automations in Home Assistant-- I think the functionality is better demonstrated using three automations (one for your prompt and two answers), but there really isn't any practical limit to how many you can have!

The first is your prompt, this is going to be your initial trigger automation. This automation is what sends your initial message on Telegram with your options. It will look something like this--

```yaml
    - alias: 'Want pizza?'
      hide_entity: true
      trigger:
        platform: time
        at: '18:30:00'    
      condition:
        - condition: state
          entity_id: device_tracker.craig_craig
          state: 'home'
        - condition: state
          entity_id: device_tracker.jess_iphone
          state: 'not_home'
      action:
        - service: telegram_bot.send_message
          data_template:
            title: 'Want pizza?'
            target: 123456789
            message: 'You look like you are home alone. Should I order you a pizza?'
            inline_keyboard:
              - "Gimme Pizza:/gimmepizza"
              - "No thanks:/nopizza"
```

The trigger and condition portions of this should look fairly familiar to you, you’ve probably got a bunch of automations that look like this in your current setup. The interesting bit is the action-- we’re calling the telegram_bot.send_message service and then using a data_template to define the message. Most of it is pretty self explanatory, the target field is the user_id and the message and title fields are the main contents of your message. The interesting part about this is the inline_keyboard field. This is where you set up your buttons!

Each button consists of two parts, the message and the payload. The two parts are separated by a colon with the message that your user sees in the message coming before the colon and the payload that gets sent back to Home Assistant. The payload is going to be a special command that you make up. It has got to start with a slash and I don’t think it can contain any spaces. This special command is what we will use to distinguish ‘Gimme Pizza’ from ‘No Thanks’.

This payload command can be reused in other prompt-like telegram message automations if you want to be able to trigger the same answer automation in a different combination of buttons in another context, or if you want to change the message side in a different context.

Now that we are able to send these messages from Home Assistant to our Telegram users, we need to define a way to handle those commands we’ve got coming in!

```yaml
    - alias: 'No pizza'
      hide_entity: true
      trigger:
        platform: event
        event_type: telegram_callback
        event_data:
          data: '/nopizza'
      action:
        - service: telegram_bot.answer_callback_query
          data_template:
            callback_query_id: '{{ trigger.event.data.id }}'
            message: 'Ok, no pizza then'
    
    - alias: 'gimme pizza'
      hide_entity: true
      trigger:
        platform: event
        event_type: telegram_callback
        event_data:
          data: '/gimmepizza'
      action:
        - service: telegram_bot.answer_callback_query
          data_template:
            callback_query_id: '{{ trigger.event.data.id }}'
            message: 'PIZZA TIME'
        - service: dominos.order
          data:
            order_entity_id: dominos.medium_pan
```

As you can see we’ve got one automation for each answer. Both automations are triggered using the built-in event platform, and the same telegram_callback event_type, the difference is that we define different event_data for them, each automation matching the payload for the corresponding button!

We can trigger whatever we want in these automations-- In both of these cases we are using the telegram_bot.answer_callback_query service to provide the user with some feedback just to say that we received the message. This uses trigger.event within a template in order to use some of the information from the triggering event in the action. In this case, we are getting the id field and using it in the callback_query_id to tell the telegram_bot.answer_callback_query

service which event we are replying to and then defining a message.

My wife and I don’t actually really use Telegram at all day-to-day, instead we usually use Facebook Messenger for text communication. So for me, getting notifications on Telegram is not tremendously practical. I’ve actually just recently modified the Facebook Messenger notification platform in Home Assistant to allow for the sending of messages like this. I’ve created this PR to have that code added into the core Home Assistant project, so that should be available in the near future. I’ll try to remember to make a post about it when it gets merged in!

Hopefully this broke things down a bit, and please don’t hesitate to leave any questions you might have as comments and I’ll do my best to address them and keep this post up to date!
c:T2309,
***Note: If you were linked here to see my telegram keyboard/callback implementation, [I've got a more complete example here](https://midwinter.cc/post/the-simple-guide-to-creating-actionable-notifications-in-home-assistant-using-telegram-s-custom-inline-keyboard-and-telegram_callbacks_SJiJnOqpG/)***

A good automation takes an action that you regularly perform and does it for you-- a great automation amplifies your laziest personality traits and takes them to new depths.

Let me be clear, my wife and I share cooking duties, but when I'm on my own I just really don’t care about cooking for
myself (also just really like pizza). That’s why when I’m home on my own and my wife is out for the evening, I’ll often
just order some pizza for myself.

Lazy? Sure, but it could be lazier-- let’s automate it!

Domino’s Pizza is my go-to pizza place, and they’ve got a pretty good online ordering system. While their API isn’t publically documented, their web-app is pretty fully featured and by opening up the dev-tools on your browser you can take a look at the requests to see what end-points do what.

Now, compiling all of this information and assembling a client library would be a somewhat tedious and painstaking job. I was very pleased to find that someone had already created this client library for the US Domino’s. The American web app is pretty much identical to the Canadian one, just on a different domain, so I just needed to make a few small changes to allow for multiple countries with different endpoints. After that, it was just a matter of creating the Home Assistant service.

Enough about how it’s made-- how do I use it?

Warning: I made this in a day during a hack-day at the office, so it’s pretty basic and a little rough around the edges.

Potential contributors: The client library supports the ability for toppings and coupons, but at the moment the Home Assistant component does not. I’m hoping to get around to adding this in, but it’s not super high on my priority list right now. Also, the current process for getting product codes isn’t the most user friendly thing in the world. I’m not exactly a front-end wizard, so if you’d like to make a panel or something to display this instead of the log dump, that would be awesome!

Right now, this isn’t yet in the core Home Assistant install, but there is
a [Pull Request](https://github.com/home-assistant/home-assistant/pull/10379) made, so it should hopefully be available
in the next release, or if you are impatient you can install the library client library via pip (pizzapi) and
then [grab the component from this gist](https://gist.github.com/craigjmidwinter/8548e572b8ee77decd83983e39b887c9) and
add it to your custom components.

To get the component configured, you are going to need to add your information to your configuration.yml like so:

```yaml
    dominos:
      country_code: ca
      first_name: Justin
      last_name: Trudeau
      email: justin.trudeau@parl.gc.ca
      phone: 6139950253
      address: 24 Sussex Dr, Ottawa, ON, K1M1M4
      show_menu: 1
```

If you are wanting to order anything, you are going to need to define some order entities! These are really simple items that live under the orders key. Right now, they just consist of a name and a list of codes, like so:

```yaml
      orders:
      - name: Medium Pan
        codes:
          - P12IPAZA
```

How do you find these order codes? Well, at the moment, it’s not exactly pretty. Currently, the best way to see the codes for the products at your nearest Dominos is to add show_menu: 1 into your config. With that set, when Home Assistant starts and the component loads, you should see a bunch of products and variants in a panel in Home Assistant. The variants represent different sizes and crust choices for the most part. It takes a bit of guesswork in order to decipher what each code represents, but for the most part, you can look at the online menu of your local dominos and compare the offerings.

Or if you are comfortable using a browser’s dev tools, you can do what I did instead and use the Dominos web app to put together an order, and then before you submit the order, turn off your network connection, open up your browser’s dev tools, hit submit and inspect the payload for the order request and have a look at the codes that are sent.

So now that you have your order codes your full config, with your customer information and a few different orders will look like so:

```yaml
    dominos:
      country_code: ca
      first_name: Justin
      last_name: Trudeau
      email: justin.trudeau@parl.gc.ca
      phone: 6139950253
      address: 24 Sussex Dr, Ottawa, ON, K1M1M4
      show_menu: 1
      orders:
      - name: Medium Pan
        codes:
          - P12IPAZA
```

With your config updated, restart Home Assistant and now you should be ready to order pizza in your scripts and automations! Let’s have a look at the one that I set up as an example--

Now, the automation that I have set up is a bit more complex than it needs to be.

If you just want to include a pizza order into a script that you run (for example, if you wanted to be able to be able to trigger a ‘movie night’ script that put your house into movie mode and ordered a pizza), you can just call the service and specify the order entity that you would like to use by adding something like this to the action on your automation and you are done:

```yaml
        - service: dominos.order
          data:
            order_entity_id: dominos.medium_pan
```

I want my pizza order to be event-based, (ie, at a certain time, if I’m the only one home), but I don’t really want it to happen every single time, I’d like to just be prompted and then have the order placed if I confirm it. For this to happen, I need some sort of actionable notification.

I decided to use Telegram for my notification platform for this since it supports actionable notifications using the custom keyboard feature, and it’s available on all the platforms that I use.

In order to accomplish this, I need to actually set up two separate automations (well, I set up three, but the third is not really necessary). Let’s take a look at the first one:

```yaml
    - alias: 'Want pizza?'
      hide_entity: true
      trigger:
        platform: time
        at: '18:30:00'    
      condition:
        - condition: state
          entity_id: device_tracker.craig_craig
          state: 'home'
        - condition: state
          entity_id: device_tracker.jess_iphone
          state: 'not_home'
      action:
        - service: telegram_bot.send_message
          data_template:
            title: 'Want pizza?'
            target: 123456789
            message: 'You look like you are home alone. Should I order you a pizza?'
            disable_notification: true
            inline_keyboard:
              - "Gimme Pizza:/gimmepizza"
              - "No thanks:/nopizza"
```

The first automation triggers at 6:30pm if I am at home and my wife is not_home. She goes to the gym in the evening several times a week at this time and we eat a bit later on those days, so I avoid her being in the not_home state by creating a zone around the gym. When the condition is met, I get a telegram message sent to me that looks like this:
![](https://s3.us-west-2.amazonaws.com/mid-midwinter.cc/images/ryt1RoiAZ.png)
The two options are buttons that basically just send back a command (defined in that inline keyboard bit) that we handle in a callback event. The automation for those callback event looks like this:

```yaml
    - alias: 'No pizza'
      hide_entity: true
      trigger:
        platform: event
        event_type: telegram_callback
        event_data:
          data: '/nopizza'
      action:
        - service: telegram_bot.answer_callback_query
          data_template:
            callback_query_id: '{{ trigger.event.data.id }}'
            message: 'Ok, no pizza then'
    
    - alias: 'gimme pizza'
      hide_entity: true
      trigger:
        platform: event
        event_type: telegram_callback
        event_data:
          data: '/gimmepizza'
      action:
        - service: telegram_bot.answer_callback_query
          data_template:
            callback_query_id: '{{ trigger.event.data.id }}'
            message: 'PIZZA TIME'
        - service: dominos.order
          data:
            order_entity_id: dominos.medium_pan
```

You can see I’ve got one that handles the no response and just gives some user feedback and then one that handles the yes response as well as calls our dominos service and specifies the order.

That inline keyboard is feature is not bound to just two options, so if I had a more adventurous palate, I could have this automation send me a variety of options for orders and let me select which one I want by handling each of the callback responses in a separate automation, but a medium pan pizza is good enough for me.
d:T1c11,
**2025 Update:** *The Goalfeed integration is now a free addon instead of a component with a paid subscription.
Everything else in this guide should still be relevant though.
See [Goalfeed Hassio Addon](https://github.com/goalfeed/hassio-goalfeed-repository)

Ok, so here’s one of the automations that I think is pretty fun-- my neighbours might disagree though. This is how I use Home Assistant to automatically trigger a goal celebration whenever the Winnipeg Jets score!

~~So, this relies on the [Goalfeed component](https://home-assistant.io/components/goalfeed/) that is in the 0.63
release of Home Assistant, which requires an account with [goalfeed.ca](https://goalfeed.ca/) (full disclosure, I wrote
and operate this service and there's a $1.99/month subscription to cover server cost and external services etc). Once
you’ve got the account and your credentials are in your configuration,~~ Home Assistant will fire events every time an
NHL or MLB team scores. These events can be used to trigger whatever automation you want.

Now, the way this component works is that it fires an event called ‘goal’ for every goal or run scored, the event has some event data that is included which basically just identifies which team scored. Ultimately, the automation is going to look like this:

```yaml
    - alias: 'Jets Goal'
      hide_entity: true
      trigger:
        platform: event
        event_type: goal
        event_data:
          team_name: "Winnipeg Jets"
      action:
      - delay: "00:00:{{ states.input_number.goalfeed.state | int }}"
      - service: homeassistant.turn_on
        entity_id: input_boolean.goaling
      - service: media_player.play_media
        data:
          entity_id: media_player.everywhere
          media_content_id: https://hassbian.local:8123/local/audio/goalhorn1718.mp3
          media_content_type: audio/mp3
      - service: script.turn_on
        entity_id: script.goal_start
```

Since we don’t want to trigger this automation every single time any team scores, we’ve got to specify the event data that we want to match in the automation trigger. You’ll notice there’s a lot going on in the action of this automation.

First, in the action, I have this delay instruction with this template:

```yaml
      - delay: "00:00:{{ states.input_number.goalfeed.state | int }}"
```    

I’ve added an input_number entity in my config like this:

```yaml
    input_number:
      goalfeed:
        name: Goalfeed Delay
        initial: 30
        min: 0
        max: 180
        step: 1
```

The reason for this is that the goalfeed events usually come in really quickly. I watch most games online, and depending on the source and my connection, the time between when the event comes in and when I see the goal sometimes requires a bit of tweaking, so having a nice little slider in the front end to configure this is key.

The next action item is setting an input_boolean (which I also added in my main config). I just set this to true to represent the fact that the goal light script is running. I’ll show you how I use this in the second automation.

The third item is the call to my media_player entity, which is a group of google homes/chrome cast audios that plays an mp3 of the Jets goal horn throughout the house.

The last item is turns on a script, which basically makes the light show work. I’ll get to that in a minute, but let’s go back to that input boolean for a second.

The input boolean that we turn on in the first automation we use as a trigger for a second automation that ends the goal celebration. That automation looks like this:

```yaml
    - alias: 'Turn off goal'
      trigger:
        platform: state
        entity_id: input_boolean.goaling
        to: 'on'
        for:
          seconds: 30
      action:
      - service: media_player.stop_media
        data:
          entity_id: media_player.everywhere
      - service: script.turn_on
        entity_id: script.goal_stop
      - service: homeassistant.turn_off
        entity_id: input_boolean.goaling
```

This is pretty straightforward-- when the input_boolean has been ‘on’ for 30 seconds, this automation runs, it runs a stop script and sets the input_boolean back to ‘off’.

Ok, now let’s take a look at the scripts for the light sequence.

```yaml
    goal_start:
      sequence:
      - service: scene.turn_on
        entity_id: scene.all_dark
      - service: script.turn_on
        entity_id: script.goal_repeat
    
    goal_loop:
      sequence:
        - condition: state
          entity_id: input_boolean.goaling
          state: 'on'
        - alias: swon
          service: homeassistant.turn_on
          data:
            entity_id: light.goallight
            rgb_color: [255, 0, 0]
            brightness: 255
            transition: 0.25
        - delay:
            seconds: 0.25
        - condition: state
          entity_id: input_boolean.goaling
          state: 'on'
        - alias: swoff
          service: homeassistant.turn_off
          data:
            entity_id: light.goallight
            transition: 0.25
        - delay:
            seconds: 0.25
        - alias: loop
          service: script.turn_on
          data:
            entity_id: script.goal_repeat
    
    goal_repeat:
      sequence:
        - condition: state
          entity_id: input_boolean.goaling
          state: 'on'
        - delay:
            seconds: 1.5
        - service: script.turn_on
          entity_id: script.goal_loop
    
    goal_stop:
      sequence:
      - service: homeassistant.turn_off
        entity_id: script.goal_loop
      - service: homeassistant.turn_off
        entity_id: script.goal_repeat
      - service: homeassistant.turn_on
        entity_id: group.main_floor
      - service: light.turn_on
        entity_id: light.goallight
        data:
          brightness: 255
          rgb_color: [255, 172, 68]
```

So, there are four scripts here in my setup. The first is the start script. This handles turning off all of my non-colour changing lights and then starts the goal loop.

The goal loop consists of two scripts and the reason why have two is that we need two scripts in order to make the looping mechanism work-- the first script has our light sequence and then it triggers the second script, which basically just triggers the first script again.

There are two things that might be worth noting about the primary goal script, but I’ve gone into more detail on both of these things in other posts, so if you are curious, feel free to follow the links to those posts. The first is using a single light entity to control a group of hue bulbs-- I outline this a bit [in this quick tip](https://midwinter.cc/post/quick-tip-controlling-colour-of-groups-of-philips-hue-lights-in-home-assistant_SJEXvIslG/). The second is the use of the transition and delay instructions-- the need for a delay in this use of transition is covered a bit more in my [post on building a sunrise alarm clock](https://midwinter.cc/post/using-home-assistant-and-philips-hue-to-create-a-full-colour-sunrise-alarm-clock_H1waliSbG/).

Feel free to comment with any questions that you might have!
e:T64d,
Just wanted to quickly post about my new night-time reading set-up since I’m pretty happy with it, so far.
![](https://s3.us-west-2.amazonaws.com/mid-midwinter.cc/images/r1U2cwpMz.png)
I hesitate to call this a scene, because when I think of a scene in the home automation context, I think of several entities getting set to a state by a single action trigger, and by that definition, this doesn’t really qualify-- but I’m hoping to change that eventually.

This really just consists of two devices:

- My bedside lamp ([Philips Hue bulb](http://amzn.to/2DLiEon))

- [My e-reader](http://amzn.to/2DHCzEN)

As I mentioned, this isn’t really much of a scene. I do have a button in Home Assistant that sets my Hue bulb to a low red colour, but the second piece of this I have to set separately.

You probably noticed in the attached image that the display on my ereader is inverted, this is a cool feature called ‘night mode’. For some reason, this feature doesn’t come stock on any e-ink e-readers as far as I know (though there might be some), but this can be added pretty easily to most major e-readers using a cool project called KoReader.

KoReader seems to support the major e-readers from what I can tell. It was dead simple to get from my factory Kobo
settings to running KoReader just by following
the [instructions on their wiki](https://github.com/koreader/koreader/wiki).

It also looks like it is super developer friendly, so maybe one day down the line I’ll see if I can add a plugin which will allow me to turn on night mode and adjust the brightness via a home assistant automation!
f:T41e6,
This is a new automation in my set-up, but it’s one I’m pretty happy with, not only because I think it’s a pretty cool effect, but for me, it’s actually a real money-saver.

Here’s how I used [Philips Hue](http://amzn.to/2jkHCCj) and [Home Assistant](https://home-assistant.io/) to build a natural coloured sunrise in my bedroom and save over $400/year--

![](https://www.youtube.com/watch?v=mccJNHih7a8)

**How does this save me money?**

I am addicted to snoozing on alarms in the morning.

In the mornings, I can either have a nice relaxing 30-minute walk into the office, or I can rush to the bus stop about 7
minutes away and catch an 10 minute bus. This choice getting left to be made by the sleepiest version of myself is no
good-- sleepy Craig sucks. He’s a lazy piece of shit. He’d sell his first-born child for an extra 13 minutes of sleep in
to morning.

Over time, taking the bus adds up. By a conservative estimate of the e-cash fare ($2.35, for now...), and saving 4 trips/week for 48 weeks, that’s $451.20 back in my pocket! Fuck yeah!

This automation has significantly cut down on how many times I hit snooze, and I also find that waking up is less jarring and I’m a lot less groggy as a result.

If you are a Home Assistant user, and you have Philips Hue bulbs or some other coloured smart lighting system setup that
supports transitions, I definitely recommend setting something like this up!

**How does it work?**

I’m going to assume that you’ve already got Home Assistant set up and working with your lights. If not, head over to homeassistant.io and give it a try. It’s really pretty easy to get up and running and the learning curve is not as steep as it looks, plus, there is a fantastic community that will provide you with support if you hit a snag.

Now, to implement this, we are going to be creating a Home Assistant script, which will be what run to create our sunrise effect, we’ll create a couple of entities to use in the front end so that we can easily configure when we want this to run, and then we’ll create the automation that will ultimate trigger the script at the desired time.

**The script**

If you’ve played around with Home Assistant a bit, you might have already got a few scripts set-up, or you might just have everything configured right in the actions of your automations. There are a couple of advantages to doing this sort of thing in a script-- the first is that scripts allow us to reuse the actions easily and then if we want to change the action, we only need to adjust it in one place. This is especially nice when we are building more involved multi-step actions like our sunrise.

Here’s what our sunrise script looks like-- It’s a long one, but I’ve got some comments there to give you an idea of what each block is doing and separated it into blocks for readability:

```yaml
    sunrise:
      sequence:
        # light 1 dark red to medium warm orange
        - service: homeassistant.turn_on
          data:
            entity_id: light.craigs_bedroom_lamp
            rgb_color: [98,19,0]
            brightness: 1
        - delay:
            seconds: 1.00
        - service: homeassistant.turn_on
          data:
            entity_id: light.craigs_bedroom_lamp
            rgb_color: [249,123,0]
            brightness: 103
            transition: 15
        - delay:
            seconds: 15.00
    
        # light 2 dark warm orange to medium warm orange
        - service: homeassistant.turn_on
          data:
            entity_id: light.jessicas_bedroom_lamp
            rgb_color: [249,123,0]
            brightness: 1
        - delay:
            seconds: 1.00
        - service: homeassistant.turn_on
          data:
            entity_id: light.jessicas_bedroom_lamp
            rgb_color: [249,123,0]
            brightness: 103
            transition: 15
        - delay:
            seconds: 15.00
    
        # group medium warm orange to full bright
        - service: homeassistant.turn_on
          data:
            entity_id: light.sunrise
            rgb_color: [255,178,67]
            brightness: 255
            transition: 30
        - delay:
            seconds: 30.00
    
    
        # turn one bulb overhead on lowest and fade to full brightness slowly
        - service: homeassistant.turn_on
          data:
            entity_id: light.bedroom_fan_1
            brightness: 1
        - delay:
            seconds: 1.00
        - service: homeassistant.turn_on
          data:
            entity_id: light.bedroom_fan_1
            brightness: 255
            transition: 60
        - delay:
            seconds: 60.00
    
        # turn on the second bulb overhead and fade to full brightness a bit faster
        - service: homeassistant.turn_on
          data:
            entity_id: light.bedroom_fan_2
            brightness: 1
        - delay:
            seconds: 1.00
        - service: homeassistant.turn_on
          data:
            entity_id: light.bedroom_fan_2
            brightness: 255
            transition: 30
    
        # no delay - also through put the corridor outside the room on
        - service: homeassistant.turn_on
          data:
            entity_id: light.upstairs_corridor
            brightness: 200
            transition: 5
```

There are a couple of things worth noting about this script. What makes this effect work well is the use of the light entities ‘transition’ attribute in combination with the ‘delay’ action in the script.

Typically, Home Assistant wants to perform actions quickly and then immediately move on to the next action. Normally, that’s exactly what we want, but in this case, it’s not. By setting the ‘transition’ in the data when we call the ‘homeassistant.turn_on’ service, we are telling Home Assistant how long it should take to transition from the lights current state to the new state. Now, we need Home Assistant to wait before performing the next step so we use the ‘delay’ action and set it to the same number as the number we have as our transition time.

I’ve played with the times and I found that for me, these are the durations that work best, but you can play with them to suit your preference.

**The entities**

Now, before we write our automation to trigger this, lets create some entities that we can use to configure this a bit easier.

I’ve got this set as two separate automations in my set-up. One for weekdays, and the other for weekends. This lets me have separate wake-up times that I don’t need to mess with too often.

Here’s the entities I’ve created:

```yaml
    input_boolean:
      weekday_sunrise:
      weekend_sunrise:
    
    input_number:
      weekday_alarm_hour:
        name: Hour
        icon: mdi:timer
        min: 0
        max: 23
        step: 1
      weekday_alarm_minutes:
        name: Minutes
        icon: mdi:timer
        min: 0
        max: 59
        step: 5
      weekend_alarm_hour:
        name: Hour
        icon: mdi:timer
        min: 0
        max: 23
        step: 1
      weekend_alarm_minutes:
        name: Minutes
        icon: mdi:timer
        min: 0
        max: 59
        step: 5
    
    sensor:
      - platform: template
        sensors:
          weekday_alarm_time:
            friendly_name: 'Time'
            value_template: '{{ "%02d:%02d" | format(states("input_number.weekday_alarm_hour") | int, states("input_number.weekday_alarm_minutes") | int) }}'
          weekend_alarm_time:
            friendly_name: 'Time'
            value_template: '{{ "%02d:%02d" | format(states("input_number.weekend_alarm_hour") | int, states("input_number.weekend_alarm_minutes") | int) }}'
```

**Okay, whoa, whoa, whoa! What the fuck are those sensors? They look complicated.**

Yeah, you can add those and not touch them, but if you want to know what they are doing, I’ll try to explain. If you don’t give a shit or already know, [skip ahead](#sunrise-entities)

As you may or may not know, [Home Assistant has support for a template engine](https://home-assistant.io/docs/configuration/templating/) called [Jinja](http://jinja.pocoo.org/). This allows you to evaluate and manipulate data at execution. These sensors that we are creating here basically takes the data and instructions that we are giving it and evaluate it as the sensors state. This is a really powerful tool to have in your Home Assistant arsenal, and I’d highly recommend looking at the Home Assistant documentation and the Jinja documentation to get a better grasp on this.

I’ll try to break down this statement and what happens behind the scenes:

```yaml
{{ "%02d:%02d" | format(states("input_number.weekday_alarm_hour") | int, states("input_number.weekday_alarm_minutes") | int) }}
```

We’ll start looking at this from the inside-out

```yaml
{{ "%02d:%02d" | **format(states("input_number.weekday_alarm_hour")** | int, states("input_number.weekday_alarm_minutes") | int) }}
```
This item in bold is just getting the state of the entity that it’s being passed. In this case, it’s going to be a string of characters representing a number-- If you remember when we created this entity, from 0-23 representing the hour we want to wake up at. Let’s pretend that we’ve got this set to 6. So this is going to end up returning “6”, and our statement now essentially looks like this:

```yaml
{{ "%02d:%02d" | format(**“6”** | int, states("input_number.weekday_alarm_minutes") | int) }}
```

Now, we’ve got the same thing happening to the other number entity.

```yaml
{{ "%02d:%02d" | format(“6” | int, **states("input_number.weekday_alarm_minutes")** | int) }}
```

This represented minutes, so it’s going to be between 0-59. Let’s pretend we’ve got this set to 30. As you can probably guess, this is going to return “30”

```yaml
{{ "%02d:%02d" | format(“6” | int, **“30”**| int) }}
```

Ok, now what is that line symbol ('|') we see in here? That’s a pipe symbol and in jinja, it’s the filter operator. Essentially, it takes what is on the left and filters it through what is on the right side.

```yaml
{{ "%02d:%02d" | format(**“6” | int**, **“30”| int**) }}
```

In the case above, we are taking “6” and putting it though the int filter. This int filter basically says to take the characters on the left side and make them a number that the computer can use. So “6” | int becomes 6 and “30” | 30. Now our statement looks like this:

```yaml
{{ "%02d:%02d" | format(**6, 30**) }}
```

Ok, that’s a bit easier to read now. Now we’ve just got some crazy characters, the filter with our numbers representing the time.

```yaml
{{ **"%02d:%02d" | format(6, 30)** }}
```

So, the format filter means to apply Python string formatting. Python string formatting is a way for you to say “I want a string of characters that looks like this” and then give it some data and get a string that looks the way you asked it to.

The crazy string of characters represents how we want the resulting string to look and the numbers in the brackets are extra data (called parameters) that we want to be formatted in this way.

[PyFormat.info](https://pyformat.info/) has some good information on all the ways you can format a string, but what you need to know about this is that the ‘%’ sign means that we are going to put the a value that is getting passed in here, the ‘d’ is the type of data that is going here (d means int). The stuff in between says how we want to display it-- the 2 means it should be 2 characters long and 0 is the character we should use to pad it if the value is too short. So for our first value 6 inserted at the first %02d becomes 06 and the second value at the second %02d becomes 30. The ‘:’ character unchanged since it is outside of the replacement which leaves us with

```yaml
{{ "06:30” }}
```

The double curly brackets in jinja just means to evaluate what is inside and output it. We already know what that is-- 06:30! That’s our sensors state!

**The other entities**

Ok, remember those other entities we set up? The non-crazy ones?

```yaml
    input_boolean:
      weekday_sunrise:
      weekend_sunrise:
    
    input_number:
      weekday_alarm_hour:
        name: Hour
        icon: mdi:timer
        min: 0
        max: 23
        step: 1
      weekday_alarm_minutes:
        name: Minutes
        icon: mdi:timer
        min: 0
        max: 59
        step: 5
      weekend_alarm_hour:
        name: Hour
        icon: mdi:timer
        min: 0
        max: 23
        step: 1
      weekend_alarm_minutes:
        name: Minutes
        icon: mdi:timer
        min: 0
        max: 59
        step: 5
```

Yeah, those ones.

I just added those their own groups like this and then added them to one of my views:

```yaml
    weekday_sunrise_panel:
        name: Weekday Alarm Clock
        entities:
          - input_boolean.weekday_sunrise
          - sensor.weekday_alarm_time
          - input_number.weekday_alarm_hour
          - input_number.weekday_alarm_minutes
    
    weekend_sunrise_panel:
        name: Weekend Alarm Clock
        entities:
          - input_boolean.weekend_sunrise
          - sensor.weekend_alarm_time
          - input_number.weekend_alarm_hour
          - input_number.weekend_alarm_minutes
```

**The automation**

Ok, so now that we’ve got our script ready to go and our entities set up in the front end, let’s make our automations!

```yaml
    - alias: 'Weekday Sunrise'
      initial_state: 'on'
      trigger:
        - platform: time
          minutes: '/1'
          seconds: 0
      condition:
        - condition: time
          weekday:
            - mon
            - tue
            - wed
            - thu
            - fri
        - condition: state
          entity_id: input_boolean.weekday_sunrise
          state: 'on'
        - condition: template
          value_template: '{{ ((as_timestamp(now())|int)|timestamp_custom("%H:%M"))  == states("sensor.weekday_alarm_time") }}'
      action:
        - service: media_player.play_media
          data:
            entity_id: media_player.everywhere
            media_content_id: https://149walnut.publicvm.com:8123/local/audio/circle-of-life.mp3
            media_content_type: audio/mp3
        - delay: 3 #this is here to compensate for the delay in playing the media over chromecast.
        - service: script.turn_on
          entity_id: script.sunrise
    
    - alias: 'Weekend Sunrise'
      initial_state: 'on'
      trigger:
        - platform: time
          minutes: '/1'
          seconds: 0
      condition:
        - condition: time
          weekday:
            - sat
            - sun
        - condition: state
          entity_id: input_boolean.weekend_sunrise
          state: 'on'
        - condition: template
          value_template: '{{ ((as_timestamp(now())|int)|timestamp_custom("%H:%M"))  == states("sensor.weekend_alarm_time") }}'
      action:
        - service: script.turn_on
          entity_id: script.sunrise
```

Here’s our two automations. Both are pretty much exactly the same, with a couple of exceptions.

The triggers are exactly the same in both. The trigger happens every minute. Obviously we don’t want this firing every minute, that’s where our conditions come into play.

The first condition is for the day of the week-- pretty straight forward. The weekday automation is set to weekdays and the weekend automation is set to weekends.

The second condition is whether or not we have our input_boolean switch enabled. We’ve got a separate switch so we can turn weekday or weekend alarms on or off independently. Each automation uses the corresponding input_boolean for this condition.

The third condition is another template! We already know how templates get evaluated. This is pretty similar. What we haven’t seen before is the == sign. This means to check for equivalence between the values on either side.

Without going into too much detail about templates again, the stuff on the right side uses some built-in functions to get the current time and output it. These built-in functions output the time as a string in the same format as the format we used for the sensor we created earlier. On the right side-- hey, look at that! We’re getting the state of our sensor! So, when the clock hits the time that we set, this will be True and our third condition will be met!

The action on both of these are similar-- they both trigger our script. The only real difference between these two actions is that on weekdays, I like to wake up to the sunrise accompanied by “The Circle of Life” from the Lion King soundtrack blaring on all my speakers… I don’t need to justify myself to you.

That’s it! If you have any questions or if you’ve implemented this yourself, let me know in the comments!
10:T621,
Just a quick little tip for anybody using Philips Hue and Home Assistant--

I noticed this while working on a component that I'm hoping to release in the next month or so, but I thought I'd post about it for anybody who might be searching about this sort of behaviour. If you are building any automations or scripts using groups of Philips Hue bulbs, instead of defining the groups in Home Assistant and using them as you normally would, instead create the group on the Hue Bridge using a Hue app.

The group that you create in the Hue app will appear as a single light entity within Home Assistant. There are a few benefits to this-- having Home Assistant address a single entity allows you for more simultaneous control over the bulbs in the group. You can see the difference if you try dimming a Home Assistant group vs the native group that appears as a light entity. When the Home Assistant group dims, each light reacts individually, however when you dim the group entity, all the lights react simultaneously.

Cleaner dimming isn't the only upside, we also are able to set colour and transition time on this light entity and have it apply to the entire group, which can be really handy.

Lastly, this is far more performant. Users with a lot of bulbs on their hub or users who are running Home Assistant on under-powered machines with a lot of devices and integrations should see a bit of a performance gain in these scenarios since it reduces the amount of requests that need to be made between Home Assistant and the Philips Hue hub from 1/device to 1/group.
11:T15d5,
A couple years ago, back when I first bought my Philips Hue lights, I posted this video of me using my lights as a notification for incoming text messages.

![](https://www.youtube.com/watch?v=z0GOOe544Ow)

Since then, I’ve been asked a few times how to do this, so I thought I’d post a tutorial on how to do this with Android.

What you’ll need:

- [Philips Hue lights](http://amzn.to/2zQyUoC)
- An Android phone
- [The Tasker app](https://play.google.com/store/apps/details?id=net.dinglisch.android.taskerm&amp;hl=en)
- [The autohue plugin](https://play.google.com/store/apps/details?id=com.cuberob.autohue&amp;hl=en)

I’m going to assume you’ve already got your lights set up for normal operations.

On your phone, open up the tasker app. At the bottom of the screen you should see a button with a plus sign in it. Hit this button to begin creating a profile trigger.
![](https://s3.us-west-2.amazonaws.com/mid-midwinter.cc/images/H1YFs4CyM.png)
From here, you will be presented with a bunch of options. We’re going to be create one based on an event.
![](https://s3.us-west-2.amazonaws.com/mid-midwinter.cc/images/BymghER1G.png)
In the screen that comes up, there is a text box at the bottom that allows you to search. Start typing ‘text’ and you should see an option that appears called ‘Received Text’. Select this option.
![](https://s3.us-west-2.amazonaws.com/mid-midwinter.cc/images/Syi43EAyM.png)
In this screen you can customize the event criteria. If you want to limit this to a single contact, you can do this by editing the sender. If you want this to trigger for every contact, we can move on without changing anything (you can always come back and edit this later). When you are done hit the back arrow in the top left of your screen.
![](https://s3.us-west-2.amazonaws.com/mid-midwinter.cc/images/r1guhN0kf.png)
Now that the trigger is made, it’s time to build the task action. You should see a menu now that has any existing tasks you have already built, and at the top is the option to create a new task. Choose the new task option and give it a name like ‘red alert’.

Now, you should see an empty task screen. Let’s add some actions to it. The first thing we’ll need is our light sequence. Hit the plus button in the lower left, and you’ll be presented with a bunch of action options.

Here, we’ll start our search for ‘hue’ until we see the option for ‘Hue 2.0’
![](https://s3.us-west-2.amazonaws.com/mid-midwinter.cc/images/r1jk6V0yG.png)![](https://s3.us-west-2.amazonaws.com/mid-midwinter.cc/images/BJxdaV01G.png)
Now that we’re in the action edit menu, we need to configure the hue alert. Hit the pencil next to Configuration in order to edit this.
![](https://s3.us-west-2.amazonaws.com/mid-midwinter.cc/images/BkuhpVAJf.png)
If this is the first time using the autohue plugin, you’ll need to set up your bridge. Unfortunately, I set mine up a long time ago, so I wasn’t able to add any information on this, but it should be pretty straight forward.

After your bridge is set up, you should see a list of your bulbs, here you can select which lights you’d like to use, you can also use the groups tab to select any groups you have set up. Select the group you want to use for this notification.

Now that you have your bulbs selected, choose the following settings

- Set Power [checked] - Power [checked]
- Set Colour [checked] - Select colour [whatever colour you’d like this notification to flash]
- Set Alert [checked] - Blink 15 seconds

Now that you have all your settings selected, select the three dots in the top right corner and choose ‘Done’, and then at the Action Edit screen, click the back arrow.

Now, if you click the play button in the bottom left, it should run this action. If you run this now, you’ll see your lights blink for the alert.

One thing you’ll notice is that your lights will stay in whatever color you set for the alert. That’s because we haven’t told the lights what to change to after. We’ll need to add another Hue 2.0 task to change them back. Before we do that though-- Tasker will execute the tasks one after another immediately after the previous task was triggered unless we tell it otherwise, so the next task we need to add is a task that tells tasker to wait.

Hit the plus button on the bottom and search for the ‘Wait’ action.
![](https://s3.us-west-2.amazonaws.com/mid-midwinter.cc/images/r1hO04RkM.png)
The only thing we need to change in here is to set Seconds to 15, which is the length of our blink sequence. If you would like your notification to be shorter than 15 seconds, you can set the seconds here to whatever your desired duration is.

Back out of this screen until you are back at the Task Edit screen. Now it’s time to add the last Hue 2.0 task. Again hit the plus button to add the final action and search for Hue 2.0

Select the bridge and bulbs you selected initially and then set the following settings:

- Set Power [checked]Power [checked]
- Set Colour [checked]Select colour [whatever colour you’d like the bulbs to return to after the notification has completed]
- Set Alert [checked]None (stop)

Back out of this all the way to the main tasker screen, make sure the profile is enabled and that tasker is enabled and you should be good to go! For the auto in my video, I just set my ringtone like normal to a red alert sound I downloaded from here: (I used the red alert sound from Star Trek, [downloaded from here](http://www.trekcore.com/audio/))

Any questions, feel free to comment and I’ll do my best to help!
12:Td97,
**2025 Update:** *The Mi Flora integration appears to be replaced by
the [Xiaomi BLE component](https://www.home-assistant.io/integrations/xiaomi_ble). I haven't used it yet, but the same
logic/process should apply*

I have a confession. I am a murderer. So many unsuspecting house plants have fallen victim to my black thumb. Luckily, I have changed my ways, thanks in no small part to this little miracle worker.

![](https://s3.us-west-2.amazonaws.com/mid-midwinter.cc/images/ByUqHgdwW.png)

The [Xiaomi Mi Flora smart plant monitor](http://amzn.to/2vhQP4K) is a wicked little plant monitor for an awesome price. The device tracks light accumulation, soil moisture, soil fertility and room temperature of your plants and reports them over bluetooth.

The stock app does a decent enough job of providing you with information about the plants that you want to monitor, but unfortunately it requires you to actively open the app and check your plants to check its needs-- not a big deal if you are a motivated gardener who just needs some help determining your plants needs, but if you are a lazy ass like me, you’re probably about as likely to remember to check the app for information as you were to remember to water them in the first place.

Luckily, some dedicated Home Assistant contributors whipped up this handy integration!

Now, admittedly, I tend to be way more enthusiastic about my home automation projects than my wife is, so when I implement something that she finds useful, I am stoked. This is one such project.

As long as you aren’t intimidated by having to enter a couple of very simple commands into the command line (and
provided you’ve got Home Assistant running on a device with Bluetooth), it’s really easy to get up and running, and once
you have it configured, all of the notification platforms provided by Home Assistant are at your fingertips.

Once you’ve connected your Mi Flora to Home Assistant, you’ll need to add automations like this to your config:

```yaml
automation:
  - alias: "Office Ficus - Water Warning"
    trigger:
      platform: numeric_state
      entity_id: sensor.office_ficus_moisture
      below: 15
    action:
      service: notify.149twitter
      data:
        message: "Office Ficus: Hey! I'm dying over here @craigjmidwinter"

  - alias: "Office Ficus - Enough Water"
    trigger:
      platform: numeric_state
      entity_id: sensor.office_ficus_moisture
      above: 50
    action:
      service: notify.149twitter
      data:
        message: "Office Ficus: About time—thanks for taking time out of your busy day to water me @craigjmidwinter"
```

You'll want to change the notify service to match whatever you previously set. You should also change out the mention since these tweets will only notify me, and I've got enough of a problem keeping my own plants alive, let alone worrying about yours.

You'll also want to change the above and below values to reflect whatever plan you have. I pulled the values here (low
15%, high 50%) for my ficus plant from the Xiaomi app’s plant database and just used them in the template. I figured it
was best to use those values as a starting point, that way if there was some variance between the actual value and the
value reported by the sensor, the values from the app's database were presumably set with this in mind.

Even if you don’t use Home Assistant, I’d highly recommend grabbing one of these sensors if you have trouble keeping plants alive.13:T77e,
I've got an old house with old electrical, and when it comes to smart lighting, the lack of common/neutral wire is a bit limiting. Luckily, [Insteon makes these wicked little 2-wire dimmers](http://amzn.to/2gSHaNb) that work in any traditional 2-wire box.
![](https://s3.us-west-2.amazonaws.com/mid-midwinter.cc/images/rJiwlVb8Z.png)
I've got 5 of these suckers in my house, and I can't say enough about them. If you are looking to teach an old house new tricks, these are definitely a great choice. These dimmers are RF-only, in contrast to the dual band in the normal Insteon dimmer switch offering, but I have to say, the range and reliability doesn't suffer a bit. One of these switches in my installation is pretty far from the hub and other switches and I have never had an issue communicating with it.

Now, it should be noted that if you don't already have an Insteon hub or PLM of some sort you'll need one in order to take advantage of the smart capabilities of this switch, but without one they'll still function like a normal dimmer. I've notice the [Insteon starter kits](http://amzn.to/2eEjB9T) seem to go on sale every so often on Amazon (as of this posting it's $40 USD), and they include the hub and two plug-in dimmer modules (for lamps).

Another thing to note is that these are not compatible replacements for three-way switches. By the looks of the reviews on the Amazon listing, it seems as though people have been burnt by that before.

## Pros

- Fast and Reliable - Have had no issues communicating with these, and they always respond really quickly
- Compatible - Works great in houses with older wiring
- Great range - I'm still able to communicate with these dimmers even when they aren't too close to another device

## Cons

- Lack dual band - these won't act as a repeater in your installation
- Pricey - these dimmers tend to be slightly more expensive than other smart dimmer options
14:T614,
Since my fiancée, Jess, and I are getting hitched in a few months, we've obviously been in the midst of wedding
planning (prior to starting work on this game). When discussing our options for music, we thought that the money we
could spend on hiring a DJ could be better spent elsewhere. Initially we were just going to put together a google music
playlist and let it run on shuffle, but then I thought it would be fun to let guests have a say in the playlist, so I
decided that I could probably build a jukebox web app pretty easily.

The jukebox application is pretty straight forward. It's a Laravel project which basically consists of two components. First, a pared-down MPD web client which users can just select a song to add to the queue. The second portion is an artisan command which runs in the background which listens for the state of MPD. Whenever the song changes, the listener checks to see if its that song is the last song in the queue, and if it is, it just queues a random song.

It's open source and [you can check it out on GitHub if you'd like](https://github.com/craigjmidwinter/jukebox) (though
I haven't touched the readme yet, it's pretty straight forward I'll try to remember to update it with some
instructions). The repository is a Homestead project, which I was using for dev, so you can probably get it going
locally with a 'vagrant up' though you might need to do some tinkering with MPD in the VM in order for it to actually
play.

In "production", I'm running it on a Raspberry Pi LEMP stack.

Step-by-step to follow...
0:{"P":null,"b":"vul8LGQyT_rPQ2jqcS-fA","p":"","c":["","blog"],"i":false,"f":[[["",{"children":["blog",{"children":["__PAGE__",{}]}]},"$undefined","$undefined",true],["",["$","$1","c",{"children":[null,["$","html",null,{"lang":"en","children":[["$","head",null,{"children":[["$","link",null,{"rel":"preconnect","href":"https://fonts.googleapis.com"}],["$","link",null,{"rel":"preconnect","href":"https://fonts.gstatic.com","crossOrigin":""}],["$","link",null,{"href":"https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap","rel":"stylesheet"}]]}],["$","body",null,{"children":["$","$L2",null,{"parallelRouterKey":"children","segmentPath":["children"],"error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L3",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":[[],[["$","title",null,{"children":"404: This page could not be found."}],["$","div",null,{"style":{"fontFamily":"system-ui,\"Segoe UI\",Roboto,Helvetica,Arial,sans-serif,\"Apple Color Emoji\",\"Segoe UI Emoji\"","height":"100vh","textAlign":"center","display":"flex","flexDirection":"column","alignItems":"center","justifyContent":"center"},"children":["$","div",null,{"children":[["$","style",null,{"dangerouslySetInnerHTML":{"__html":"body{color:#000;background:#fff;margin:0}.next-error-h1{border-right:1px solid rgba(0,0,0,.3)}@media (prefers-color-scheme:dark){body{color:#fff;background:#000}.next-error-h1{border-right:1px solid rgba(255,255,255,.3)}}"}}],["$","h1",null,{"className":"next-error-h1","style":{"display":"inline-block","margin":"0 20px 0 0","padding":"0 23px 0 0","fontSize":24,"fontWeight":500,"verticalAlign":"top","lineHeight":"49px"},"children":404}],["$","div",null,{"style":{"display":"inline-block"},"children":["$","h2",null,{"style":{"fontSize":14,"fontWeight":400,"lineHeight":"49px","margin":0},"children":"This page could not be found."}]}]]}]}]]],"forbidden":"$undefined","unauthorized":"$undefined"}]}]]}]]}],{"children":["blog",["$","$1","c",{"children":[null,["$","$L2",null,{"parallelRouterKey":"children","segmentPath":["children","blog","children"],"error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L3",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":"$undefined","forbidden":"$undefined","unauthorized":"$undefined"}]]}],{"children":["__PAGE__",["$","$1","c",{"children":[["$","$L4",null,{"posts":[{"slug":"2018-07-smart-home-vs-home-automation-whats-the-difference","title":"Smart Home vs. Home Automation – What’s the difference?","date_published":"$D2018-07-05T00:11:00.000Z","date_updated":"$D2018-12-21T20:47:44.000Z","tags":"Smart Home, Home Automation","cover_image":"/assets/blog/capacitors-chip-circuit-board-57007.jpg","content":"$5"},{"slug":"2018-06-i-hired-a-dude-who-voices-nike-commercials-to-tell-me-when-my-cat-litter-is-full","title":"I hired a dude who voices Nike commercials to tell me when my cat litter is full","date_published":"$D2018-07-04T00:00:00.000Z","date_updated":"$D2018-12-21T20:48:22.000Z","tags":"Home Assistant, Home Automation, Node-RED","cover_image":"/assets/blog/computer-electronics-laptop-755416.jpg","content":"$6"},{"slug":"2018-06-automatic-litterbox-notifications-using-an-home-assistant-and-node-red-with-an-external-rest-api","title":"Automatic Litterbox Notifications – Using an Home Assistant and Node Red with an external REST API","date_published":"$D2018-06-24T00:03:00.000Z","date_updated":"$D2018-12-21T20:49:02.000Z","tags":"Node-RED, Home Assistant, Home Automation, Programming","cover_image":"/assets/blog/IMG_20171111_140343.jpg","content":"$7"},{"slug":"2018-05-making-my-dumb-bed-smart-home-assistant-bed-occupancy-sensor","title":"Making my dumb bed, smart – Home Assistant Bed Occupancy Sensor","date_published":"$D2018-05-20T23:43:00.000Z","date_updated":"$D2018-12-31T14:49:22.000Z","tags":"Home Assistant, MQTT, NodeMCU, Arduino, Home Automation, Programming","cover_image":"/assets/blog/IMG_20180518_174346.jpg","content":"$8"},{"slug":"2018-05-smart-garbage-pt-1-pattern-for-deferring-service-calls-in-home-assistant","title":"Smart Garbage! – Pattern for deferring service calls in Home Assistant","date_published":"$D2018-05-16T23:27:00.000Z","date_updated":"$D2018-12-31T14:49:50.000Z","tags":"Home Assistant, Home Automation, YAML, Design Patterns","cover_image":"","content":"$9"},{"slug":"2018-05-telegram-keyboard-and-callbacks-in-home-assistant-with-node-red","title":"Telegram keyboard and callbacks in Home Assistant with Node-RED","date_published":"$D2018-05-10T22:56:00.000Z","date_updated":"$D2018-12-21T20:50:30.000Z","tags":"Home Assistant, Home Automation, Telegram, Node-RED","cover_image":"","content":"$a"},{"slug":"2018-05-the-simple-guide-to-creating-actionable-notifications-in-home-assistant-using-telegrams-custom-inline-keyboard-and-telegram_callbacks","title":"The simple guide to Telegram's custom inline keyboard","date_published":"$D2018-05-04T22:27:00.000Z","date_updated":"$D2018-12-11T22:42:45.000Z","tags":"Home Assistant, Telegram, YAML, Home Automation","cover_image":"","content":"$b"},{"slug":"2017-11-my-house-automatically-orders-pizza-for-me-dominos-pizza-automation-using-home-assistant","title":"My house automatically orders pizza for me – Dominos Pizza automation using Home Assistant.","date_published":"$D2018-05-04T22:17:00.000Z","date_updated":"$D2018-12-14T03:59:33.000Z","tags":"Home Assistant, YAML, Programming, Dominos, Home Automation, Telegram","cover_image":"","content":"$c"},{"slug":"2018-02-nhl-goal-light-celebration-with-home-assistant-and-philips-hue","title":"NHL goal light celebration with Home Assistant and Philips Hue","date_published":"$D2018-02-11T22:02:00.000Z","date_updated":"$D2018-12-14T03:46:14.000Z","tags":"Home Assistant, Home Automation, NHL, Goallight, Philips Hue, Goalfeed, YAML","cover_image":"","content":"$d"},{"slug":"2017-12-my-nighttime-reading-setup-using-philips-hue-and-koreader","title":"Night-time reading with KoReader and Philips Hue","date_published":"$D2018-01-19T21:14:00.000Z","date_updated":"$D2018-12-12T01:19:52.000Z","tags":"Philips Hue, KoReader","excerpt":"Using Philips Hue and KoReader for nighttime reading","cover_image":"","content":"$e"},{"slug":"2017-12-using-home-assistant-and-philips-hue-to-create-a-full-colour-sunrise-alarm-clock","title":"Using Home Assistant and Philips Hue to create a full colour sunrise","date_published":"$D2017-12-06T21:58:00.000Z","date_updated":"$D2018-12-21T20:51:44.000Z","tags":"Home Assistant, YAML, Philips Hue, Home Automation","cover_image":"/assets/blog/sunrise.jpg","content":"$f"},{"slug":"2017-11-quick-tip-controlling-colour-of-groups-of-philips-hue-lights-in-home-assistant","title":"Quick Tip: Controlling Colour of Groups of Philips Hue Lights in Home Assistant","date_published":"$D2017-11-28T22:12:00.000Z","date_updated":"$D2018-12-12T01:17:37.000Z","tags":"Home Assistant, Home Automation, Philips Hue","cover_image":"","content":"$10"},{"slug":"2017-11-philips-hue-and-tasker-use-your-lights-as-a-notification-for-text-messages","title":"Philips Hue and Tasker – Use your lights as a notification for Text Messages","date_published":"$D2017-11-19T22:57:00.000Z","date_updated":"$D2018-12-21T21:05:44.000Z","tags":"Tasker, Android, Philips Hue, Home Automation","cover_image":"/assets/blog/text.jpg","content":"$11"},{"slug":"2017-08-using-the-xiaomi-mi-flora-and-home-assistant-for-twitter-enabled-plants","title":"Using the Xiaomi Mi Flora and Home Assistant for Twitter enabled plants","date_published":"$D2017-11-19T21:34:00.000Z","date_updated":"$D2018-12-21T21:06:11.000Z","tags":"Home Automation, Home Assistant, Twitter, Xiaomi, YAML","cover_image":"/assets/blog/2017-08-using-the-xiaomi-mi-flora-and-home-assistant-for-twitter-enabled-plants/tweet-plant.jpg","content":"$12"},{"slug":"2017-07-insteon-switchlinc-2-wire-dimmer-review","title":"Insteon SwitchLinc 2-wire Dimmer Review","date_published":"$D2017-08-09T23:10:00.000Z","date_updated":"$D2018-12-12T01:15:16.000Z","tags":"Insteon, Home Automation, Reviews","cover_image":"","content":"$13"},{"slug":"2017-07-raspberry-pi-jukebox","title":"True MPD Jukebox using Raspberry Pi","date_published":"$D2017-08-09T21:28:00.000Z","date_updated":"$D2018-12-21T21:06:58.000Z","tags":"Raspberry Pi, Programming","cover_image":"/assets/blog/mpd-jukebox/mpd-jukebox.jpg","content":"$14"}]}],null,["$","$L15",null,{"children":"$L16"}]]}],{},null,false]},null,false]},null,false],["$","$1","h",{"children":[null,["$","$1","i1B5QyKYMdy7ABJM84YGk",{"children":[["$","$L17",null,{"children":"$L18"}],["$","$L19",null,{"children":"$L1a"}],null]}]]}],false]],"m":"$undefined","G":["$1b","$undefined"],"s":false,"S":true}
1a:[["$","meta","0",{"name":"viewport","content":"width=device-width, initial-scale=1"}]]
18:[["$","meta","0",{"charSet":"utf-8"}],["$","title","1",{"children":"Craig Midwinter - Personal Website"}],["$","meta","2",{"name":"description","content":"Welcome to my personal website. Check out my resume, GitHub, LinkedIn, podcast, and blog posts."}],["$","link","3",{"rel":"icon","href":"/favicon.ico","type":"image/x-icon","sizes":"16x16"}]]
16:null
