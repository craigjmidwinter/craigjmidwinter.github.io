1:"$Sreact.fragment"
2:I[15244,[],""]
3:I[43866,[],""]
5:I[86213,[],"OutletBoundary"]
7:I[86213,[],"MetadataBoundary"]
9:I[86213,[],"ViewportBoundary"]
b:I[34835,[],""]
:HL["/craigjmidwinter.github.io/_next/static/css/a2fe316cdd23b4ed.css","style"]
0:{"P":null,"b":"w_tnSzuQa1qxRBTjk73d2","p":"/craigjmidwinter.github.io","c":["","blog","2018-05-telegram-keyboard-and-callbacks-in-home-assistant-with-node-red",""],"i":false,"f":[[["",{"children":["blog",{"children":[["slug","2018-05-telegram-keyboard-and-callbacks-in-home-assistant-with-node-red","d"],{"children":["__PAGE__",{}]}]}]},"$undefined","$undefined",true],["",["$","$1","c",{"children":[[["$","link","0",{"rel":"stylesheet","href":"/craigjmidwinter.github.io/_next/static/css/a2fe316cdd23b4ed.css","precedence":"next","crossOrigin":"$undefined","nonce":"$undefined"}]],["$","html",null,{"lang":"en","children":[["$","head",null,{"children":[["$","link",null,{"rel":"preconnect","href":"https://fonts.googleapis.com"}],["$","link",null,{"rel":"preconnect","href":"https://fonts.gstatic.com","crossOrigin":""}],["$","link",null,{"href":"https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap","rel":"stylesheet"}]]}],["$","body",null,{"children":["$","div",null,{"id":"root","children":["$","$L2",null,{"parallelRouterKey":"children","segmentPath":["children"],"error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L3",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":[[],[["$","title",null,{"children":"404: This page could not be found."}],["$","div",null,{"style":{"fontFamily":"system-ui,\"Segoe UI\",Roboto,Helvetica,Arial,sans-serif,\"Apple Color Emoji\",\"Segoe UI Emoji\"","height":"100vh","textAlign":"center","display":"flex","flexDirection":"column","alignItems":"center","justifyContent":"center"},"children":["$","div",null,{"children":[["$","style",null,{"dangerouslySetInnerHTML":{"__html":"body{color:#000;background:#fff;margin:0}.next-error-h1{border-right:1px solid rgba(0,0,0,.3)}@media (prefers-color-scheme:dark){body{color:#fff;background:#000}.next-error-h1{border-right:1px solid rgba(255,255,255,.3)}}"}}],["$","h1",null,{"className":"next-error-h1","style":{"display":"inline-block","margin":"0 20px 0 0","padding":"0 23px 0 0","fontSize":24,"fontWeight":500,"verticalAlign":"top","lineHeight":"49px"},"children":404}],["$","div",null,{"style":{"display":"inline-block"},"children":["$","h2",null,{"style":{"fontSize":14,"fontWeight":400,"lineHeight":"49px","margin":0},"children":"This page could not be found."}]}]]}]}]]],"forbidden":"$undefined","unauthorized":"$undefined"}]}]}]]}]]}],{"children":["blog",["$","$1","c",{"children":[null,["$","$L2",null,{"parallelRouterKey":"children","segmentPath":["children","blog","children"],"error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L3",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":"$undefined","forbidden":"$undefined","unauthorized":"$undefined"}]]}],{"children":[["slug","2018-05-telegram-keyboard-and-callbacks-in-home-assistant-with-node-red","d"],["$","$1","c",{"children":[null,["$","$L2",null,{"parallelRouterKey":"children","segmentPath":["children","blog","children","$0:f:0:1:2:children:2:children:0","children"],"error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L3",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":"$undefined","forbidden":"$undefined","unauthorized":"$undefined"}]]}],{"children":["__PAGE__",["$","$1","c",{"children":["$L4",null,["$","$L5",null,{"children":"$L6"}]]}],{},null,false]},null,false]},null,false]},null,false],["$","$1","h",{"children":[null,["$","$1","aURDUw6N7kThZnlVC9UO9",{"children":[["$","$L7",null,{"children":"$L8"}],["$","$L9",null,{"children":"$La"}],null]}]]}],false]],"m":"$undefined","G":["$b","$undefined"],"s":false,"S":true}
c:I[86880,["844","static/chunks/ee560e2c-c5c28398d0153d35.js","322","static/chunks/322-53eb1d32bf710b44.js","173","static/chunks/173-52b2b489d82616e2.js","590","static/chunks/590-97f4dc9b90039a27.js","953","static/chunks/app/blog/%5Bslug%5D/page-9af1e0a685a480c8.js"],"default"]
d:T221f,

https://github.com/goalfeed/hassio-goalfeed-repository
Last week I
made [this blog post](/blog/2017-11-my-house-automatically-orders-pizza-for-me-dominos-pizza-automation-using-home-assistant)
describing how to use the Telegram inline keyboard and callback functions within Home Assistant. I posted the article to
Reddit and a user left a comment wondering how to accomplish this within Node-RED, so I thought I’d make a quick post on
how to do that.

Now, I am not a Node-RED expert by any means-- it’s actually been a couple of years since I’ve tried doing anything with it, but I’ve noticed more and more people are starting to use it to handle their automations and I can definitely see it’s advantages. Personally, I haven’t encountered any real insurmountable limitations using Home Assistants baked-in YAML-based automation engine, and I’m not the most visually-oriented person so I’m not in a huge rush to start changing over all my automations, but it’s definitely a tool that I would consider in the future.

I prefaced this tutorial with the fact that I am not a Node-RED expert because there are a lot of ways this flow could be accomplished, and I’m not 100% sure if my implementation breaks any common conventions-- there could be a more Node-REDy way to do this, and if there is, please leave me a comment to let me know what you would do different!

If you are looking for a real Node-RED guru or a crash-course on some of the fundamentals of integrating Node-RED with Home Assistant, I recommend checking out the excellent [DIY Futurism blog by u/diybrad](https://diyfuturism.com/). He’s great Home Automation blogger who has got a lot of excellent posts about his implementations of automations in Node-RED and it’s a great point of reference for anybody just starting out with the tool.

## Assumptions

I’m going to assume that you already have Node-RED running and configured with your Home Assistant installation. If you haven’t, check out [this post on DIY Futurism](https://diyfuturism.com/index.php/2017/11/26/the-open-source-smart-home-getting-started-with-home-assistant-node-red/) for how to do that. Additionally, like my previous post on this matter, I’m going to assume that you have configured the telegram_bot platform using [the webhook](https://www.home-assistant.io/components/telegram_bot.webhooks/) or [polling method](https://www.home-assistant.io/components/telegram_bot.polling/) on your Home Assistant install.

Ok, now that that’s all out of the way, let’s get our hands dirty!
![](https://s3.us-west-2.amazonaws.com/mid-midwinter.cc/images/BkVNvaZRz.png)

## Inline Keyboard

If you have ever created an automation for Home Assistant in Node-RED, this is going to look pretty familiar to you. In this case, for demonstration purposes I’m just using the Inject node to trigger the initial message. In any other practical automation, you’ll probably use some other event within Home Assistant and/or have some sort of logic that is going to trigger it, but whatever that might be, the message is going to flow to the call service node in order to trigger our message. Let’s take a look at that node to see what it looks like:
![](https://s3.us-west-2.amazonaws.com/mid-midwinter.cc/images/r1bqwaZCz.png)
The really important bits of this are the ‘domain’, ‘service’, and ‘data’ field. Domain and service are pretty straight-forward. The domain is going to be ‘telegram_bot’ and the service is ‘send_message’. Now, let’s look at the data-- you can’t see it all in the screenshot and it’s hard to read all on one line anyways, so here’s a better look:

    {
      "target": "123456789",
      "title": "Want pizza?",
      "message": "You look like you are home alone. Should I order you a pizza?",
      "inline_keyboard": [
        "Gimme Pizza:\/gimmepizza",
        "No thanks:\/nopizza"
      ]
    }

You can see in our json object we are setting the target to our chat id, then setting the title and message fields, and then we have the inline_keyboard field, which is getting set to an array of a few specifically formatted strings. Each button consists of two parts, the message text and the message command. The two parts are separated by a colon with the text that your user sees coming before the colon and the message command that gets sent back to Home Assistant coming after. The message command is going to be a special text string that you make up. It has got to start with a slash and I don’t think it can contain any spaces. This command is what we will use to distinguish ‘Gimme Pizza’ from ‘No Thanks’.

## Telegram Callbacks

Now, let’s take a look at the automation flow to handle the reply!
![](https://s3.us-west-2.amazonaws.com/mid-midwinter.cc/images/BypVOTZ0z.png)
Look at this! It’s nice and small-- let’s break it down!

The first piece here is the events:all node. It sends a message down the flow for every single event that happens within Home Assistant. Obviously, we only want to react to certain events, so we’re going to pipe this into a function node to filter it out. The code in that function looks like this:

    if(msg.payload.event_type == "telegram_callback") {
        msg.payload.data = {"callback_query_id": msg.payload.event.id};
        return msg;    
    }

What this does is use an if statement to filter through all the messages coming in and only allow messages of the telegram_callback event type through, if it matches that event_type, it also manipulates the message payload before passing it on to the next node. It does this by adding an object named ‘data’ to it and initializing this object with one property on it called “callback_query_id” with the value of msg.payload.event.id. If you are wondering why msg.payload.event.id is not in quotes, that’s because in this case we are referring to the value of msg.payload.event.id not the literal string “msg.payload.event.id”.

This function here is the main reason why I said that I am not entirely sure if there is a more Node-REDy way to do this. It definitely works to do it this way, but there are two things I could see possibly going against common Node-RED. First, there may be a more simpler way of filtering out all messages that don’t match on a single value with another core node type that does not require writing code, and second (and I expect this is more of an issue than the first point) the function, while simple, has more than one responsibility-- that is to say, it both filters out messages and manipulates the message in a single node. It might be common practice to separate these responsibilities in to two different nodes in order to better represent the logic visually.

With that said, I think this is an elegant enough way of handling the data here. If you are planning on having a lot of different telegram_callback automations, I’d recommend saving the first two nodes in this as a sub-flow so that you can reuse it as the entrypoint for all your callback automations.

On to the next node!
![](https://s3.us-west-2.amazonaws.com/mid-midwinter.cc/images/HyPi-T@0M.png)
The next node here is a simple switch and if we look at how this node is configured, you can see that it is matching on the two commands that we defined in our keyboard in the initial message, with a separate exit-point for each of the two responses.
![](https://s3.us-west-2.amazonaws.com/mid-midwinter.cc/images/r1zaKabRf.png)
From both the exit point of the ‘No’ and the 'Yes' response we just flow into a change node. They both look very similar to this, the only difference is what we set the reply message to. We use this change node to add a field called message to the data object and set it to the message we want to send in the callback.  I’ve also got the yes exit point flowing into another service call just to illustrate where we would branch off and fire our automation.

Both the yes and no change nodes flow into the same service call node. Here’s how that looks--
![](https://s3.us-west-2.amazonaws.com/mid-midwinter.cc/images/HkGm9aZAM.png)![](https://149walnut.com/images/HkGm9aZAM.png)
This node calls the answer_callback_query service of telegram_bot. We set the data in this node to be an empty object by using a set of empty curly-boys (that’s definitely a technical term). We don’t need to set the data here for the same reason that we can share this node for both yes and no-- The Home Assistant service call node will look for the data object in the payload we created and use that for the data in the service call if it exists!

That should about cover it! Please feel free to comment with any questions or improvements you might have!
4:["$","$Lc",null,{"post":{"slug":"2018-05-telegram-keyboard-and-callbacks-in-home-assistant-with-node-red","title":"Telegram keyboard and callbacks in Home Assistant with Node-RED","date_published":"$D2018-05-10T22:56:00.000Z","date_updated":"$D2018-12-21T20:50:30.000Z","tags":"Home Assistant, Home Automation, Telegram, Node-RED","cover_image":"","content":"$d"}}]
a:[["$","meta","0",{"name":"viewport","content":"width=device-width, initial-scale=1"}]]
8:[["$","meta","0",{"charSet":"utf-8"}],["$","title","1",{"children":"Craig Midwinter - Personal Website"}],["$","meta","2",{"name":"description","content":"Welcome to my personal website. Check out my resume, GitHub, LinkedIn, podcast, and blog posts."}],["$","link","3",{"rel":"icon","href":"/craigjmidwinter.github.io/favicon.ico","type":"image/x-icon","sizes":"16x16"}]]
6:null
